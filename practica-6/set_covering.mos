(! 
	Problema Set Covering (cubrimiento total) 
	Datos CYL enteros, con precisión 10 (unidades cientos de metros)     
	La distancia de cubrimiento dc hay que multiplicarla por 10 también.
	Solución óptima y solución greedy con un RCL, y 
	con eliminación posterior de columnas redundantes
!)

model "Modelo scp_cyl_int_greedy_opt_1"
		uses "mmxprs"
		uses "mmsystem"
	
	declarations
		m, n				: integer  
		archivo_datos		= "data/matriz30x30.dat"
		N					= 100;		! Número de arranques
		K					= 4;		! Tamaño del RCL
	end-declarations
	
	!================== LECTURA DE DATOS =========================
	fopen(archivo_datos, F_INPUT);
	readln(m);
	readln(n);
	
	declarations
		p_demanda			= 1..m;
		p_servicio			= 1..n;
		dem					:array(p_demanda) of integer;
		dist				:array(p_demanda,p_servicio) of integer;
		a					:array(p_demanda,p_servicio) of integer;
		x					:array(p_servicio) of mpvar;
		
		dcmin, dcmax		:integer;
		daux, dmm			: integer;
		
		nfilcub:integer;
		varfijada, solu, d	: array(p_servicio) of integer;
		filacubierta, w		: array(p_demanda) of integer;
		
		jk					: integer;
		indrcl, marcado		: array(p_servicio) of integer
	end-declarations
	
	dem_total := 0;
	forall(i in p_demanda) do
		readln( dem(i) );
		dem_total += dem(i);
	end-do
	forall(i in p_demanda, j in p_servicio)
		read( dist(i,j) );
	fclose(F_INPUT);
	 
	!==================== Calculos previos =============================
	writeln("\nModelo scp_cyl_int_greedy_opt_1 de Set Covering\n");
	writeln("Fichero de datos: ", archivo_datos);
	writeln("Parametros fundamentales: m =", m, ", n = ", n);
	
	writeln("Calculos previos: dem_total = ", dem_total);
	
	! Calculo la distancia mínima máxima dmm de un p. de demanda a uno de servicio 
	! y tiene que ser DM > dmm para que haya soluciones
	starttime := gettime;
	
	
	dmm := -MAX_INT;
	forall(i in p_demanda) do
		daux := MAX_INT;
		forall(j in p_servicio) do
			if(dist(i,j) < daux) then
				daux := dist(i,j);
			end-if
		end-do 
		if(daux > dmm) then
			dmm := daux;
		end-if
	end-do
	writeln("Mínima distancia máxima = ", dmm);
	
	dcmin := dmm;
	dcmax := dcmin + 100;
	writeln("Método Greedy RCL con N = ", N, ", K = ", K);
	
	write("\ndc\tXpress\tGreedy_RCL");
	forall(dc in dcmin..dcmax) do
		forall(i in p_demanda, j in p_servicio) do
			if(dist(i,j) <= dc) then
		  		a(i,j) := 1;
			else
		  		a(i,j) := 0;
			end-if
		end-do
	
		!=========================== MODELO ===============================
		forall(j in p_servicio)
			x(j) is_binary;
		
		obj := sum(j in p_servicio) x(j);
		
		! forall(i in p_demanda)res_dem(i):= 
		!	   sum(j in p_servicio|dist(i,j)<=dc)x(j)>=1
			   
		forall(i in p_demanda)
			res_cub(i) := sum(j in p_servicio) a(i,j) * x(j) >= 1;
		
		!exportprob(EP_MIN,"a1_28_2",obj)
		!======================= SOLUCION ÓPTIMA CON XPRESS=========================
		!writeln("\n\nSolución para dc = ",dc,":\n")
		
		minimize(obj)
			
		if(getprobstat = XPRS_OPT) then
			write("\n", dc, "\t", getobjval);
		elif(getprobstat = XPRS_INF) then
			writeln(dc, "\t\tProblema no factible");
		end-if
		
		finaltime := gettime;
		
		forall(i in p_demanda) do
			w(i) := 0;
			forall(j in p_servicio | x(j).sol >= 0.99 and a(i,j) = 1)
				w(i) += 1;
		end-do
		
		!writeln("w ?ptimo = ",w)
		
		!================= Método GREDDY con RCL =============================
		zbest := MAX_INT;
		forall(t in 1..N) do
			forall(j in p_servicio) do
				varfijada(j) := 0;
				solu(j) := 0;
				marcado(j) := 0;
			end-do
			nfilcub := 0;
			forall(i in p_demanda)
				filacubierta(i) := 0;
		
			while(nfilcub < m) do
				!calculo d(j) = número de filas que cubre cada columna
				forall(j in p_servicio | varfijada(j) = 0) do
					d(j) := 0;
					forall(i in p_demanda | filacubierta(i) = 0) do
						if(a(i,j) = 1) then
							d(j) += 1;
						end-if
					end-do
					if(d(j) = 0) then
						varfijada(j) := 1;
						solu(j) := 0;
					end-if
				end-do
				! RCL
				forall(j in p_servicio) marcado(j) := 0;
				forall(r in 1..K) do
					dmax := -MAX_INT;
					forall(j in p_servicio | varfijada(j) = 0 and marcado(j) = 0) do
						if(d(j) > dmax) then
							dmax := d(j);
							jmax := j;
						end-if
					end-do
					marcado(jmax) := 1;
					indrcl(r) := jmax;
				end-do
				jk := indrcl( ceil(random*K) );
				varfijada(jk) := 1;
				solu(jk) := 1;
				forall(i in p_demanda | filacubierta(i) = 0) do
					if(a(i,jk) = 1) then
						filacubierta(i) := 1;
						nfilcub += 1;
					end-if
				end-do
			end-do
			zp1 := sum(j in p_servicio) solu(j);
			!writeln("\nIteración ",t," Greedy RCL => Número de instalaciones = ",zp1)
			
			!========	Eliminación de columnas redundantes =======================
			
			forall(i in p_demanda) do
				w(i) := 0;
				forall(j in p_servicio)
					if(solu(j) = 1 and a(i,j) = 1) then
						w(i) += 1;
					end-if
			end-do
		
			forall(k in p_servicio | solu(k) = 1) do
				elimin := 1
				forall(i in p_demanda)
					if(w(i) < 1 + a(i,k)) then
						elimin := 0;
			      	end-if
				if(elimin = 1) then
					solu(k) := 0;
					forall(i in p_demanda)
						w(i) := w(i) - a(i,k);
				end-if
			end-do
			
			zp2 := sum(j in p_servicio) solu(j);
		
			if(zp2 < zbest) then
				zbest := zp2;
			end-if
		end-do  ! final de forall(t in 1..N)
		write("\t", zbest);
		
	end-do  ! final de forall(dc in dcmin..dcmax)
	
	writeln("\nTiempo total = ", gettime - starttime, " segundos\n");
end-model
